# Game Engine

## Краткое описание

Данный репозиторий содержит решение (solution) Microsoft Visual Studio 2022, выполняющее две роли:

<ol>
	<li>Адаптор-обёртка для DirectX (Direct2D/DirectWrite) и WinAPI</li>
	<li>Небольшая библиотека классов, реализующая базовые аспекты игр</li>
</ol>

Текущий проект написан на C++ с использованием, преимущественно, стандарта 20-го года и преследует исключительно учебные цели. Тем не менее, он является вполне самостоятельным и функционирующим игровым 2D-движком, что, в частности, доказывается примерами:

<ol>
	<li>Arkanoid - вариант известной игры с разбиванием блоков шариком</li>
	<li>Starfield - простое приложение с случайно генерируемым звёздным полем и управляемой камерой</li>
	<li>PaintItGit - пошаговое закрашивание блоков с версионным контролем</li>
</ol>

### Функционал

Здесь можно найти реализацию:
- окон на WinAPI (класс `GameEngine::MainWindow` в проекте MainWindow) с отслеживанием нажатых клавиш и положения курсора на экране
- матриц (класс `GameEngine::Geometry::Matrices::Matrix` в проекте GameEngine), способных вычисляться во время компиляции
- основных аффинных преобразований с использованием матриц
- математического вектора (класс `GameEngine::Geometry::Vector2D` в проекте GameEngine) для двумерного пространства
- игрового 3-х этапного (Proccess Input -> Update -> Render) игрового цикла (класс `GameEngine::Game`)
- механизма синхронизации скорости генерации кадров и обновления состояния игры (класс `GameEngine::FrameTimer` в проекте GameEngine)
- отрисовки графических примитивов, текста, битмап с возможностью задания "прозрачных" пикселей (класс `GameEngine::GraphicsDirect2D` в проекте GameEngine)
- автоматического выделения и освобождения ресурсов, предоставляемых Direct2D (класс `GameEngine::Direct2DFactory` в проекте GameEngine)
- исключений для обработки ошибок в WinAPI (класс `GameEngine::WinApiException` в проекте GameEngine) и Direct2D (класс `GameEngine::Direct2dException` в проекте GameEngine)

### Установка и внедрение в другие проекты

Если установлен Microsoft Visual Studio 2022, то достаточно скачать содержимое репозитория и открыть файл решения GameEngine.sln
При этом необязательные проекты: Matrices, Arkanoid, PaintItGit, Starfield, MainWindow. Все перечисленные подпроекты являются зависимыми от проекта GameEngine и включены в общее решение, поэтому отдельно их собрать не получится.

Затем, чтобы получить исполняемый файл, нужно нажать "Сборка"->"Собрать решение", после чего можно будет запустить либо одно из представленных приложений в репозитории, либо сам игровой движок (будет черное окно).

Все файлы представляют собой исходный код, связанный между собой директивой препроцессора `#include`, поэтому их можно свобдно использовать в других программах при условии соблюдения `#include` зависимостей.


### Примеры использования

Строго говоря, присутсвующие в решении проекты сами по себе являются примерами использования данного игрового движка. Однако для быстрого ознакомления стоит коснуться базовых аспектов работы с компонентами репозитория и дать некоторые комментарии к типовому коду.

После клонирования репозитория можно удалить все проекты, кроме GameEngine и MainWindow. Чтобы не нарушать пути в директивах `#include` между компонентами можно в рамках решения GameEngine создать новый проект Windows-приложения и добавить в него (ПКМ по фильтру "Исходные файлы"->"Добавить"->"Существующий элемент...") все .cpp файлы (или по мере надобности). Репозиторий не являются библиотекой шаблонов, хотя некоторые компоненты действительно описаны в шаблонах, поэтому компиляция необходима.

Итак, чтобы создать свою игру следует наследовать класс `GameEngine::Game`, например:

```C++
class TestGame : public GameEngine::Game
{
	TestGame(GameEngine::Interfaces::IWindow& window, GameEngine::Interfaces::IFramableGraphics2D& graphics)
	:
	Game{ window, graphics }
	{ }
}
```

Для интерфейса `GameEngine::Interfaces::IWindow` в проекте MainWindow предусмотрена простая реализация `GameEngine::MainWindow`, а для `GameEngine::Interfaces::IFramableGraphics2D` можно взять `GameEngine::GraphicsDirect2D`. В итоге, инциализация объекта класса `TestGame` может выглядеть так:

```C++
int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE, _In_ LPSTR lpCmdLine, _In_ int nCmdShow)
{
    MainWindow m_wnd{ hInstance, nCmdShow, L"Test App" };
    GraphicsDirect2D graphics{ m_wnd.get_window_handler() };
    TestGame theGame{ m_wnd, graphics };
    theGame.start();

    return EXIT_SUCCESS;
}
```

В результате будет отображено чёрное окно. 

Вся логика игры заключена в 3-х методах класса `GameEngine::Game`:

- `virtual void process()` - этот метод предназначен для обработки очереди сообщений. В общем случае, его можно не переопределять
- `virtual void update()`  - переопределение этого метода должно содержать логику изменения состояния игры
- `virtual void render()`  - отрисовка мира и моделей

В методе `update` следует располагать всю логику обработки и изменения мира (состояния игры), а отрисовку (вывод на окно) - в методе `render`. Метод `process` в общем случае переопределять не нужно, однако если используется свой обработчик событий окна, клавиатуры мыши и т.д., то рекомендуются следующий подход:

```C++
void TestGame::process()
{
	Game::process();
	// остальной код...
}
```

Вызов метода `GameEngine::Game::start` запускает бесконечный игровой цикл, который будет завершен автоматически при закрытии окна или вызова метода `GameEngine::Game::stop`. Более подробные примеры использования игрового движка представлены в проектах Arkanoid, PaintItGit, StarField.

## О приложениях, демонстрирующих данный игровой движок

В этом разделе приведено краткое описание приложений, цель которых заключается в демонстрации того, что можно сделать с использованием текущего игрового движка. Разумеется, поскольку сама концепция предлагаемого фреймворка, или, вернее сказать, адаптора для Direct2D/DirectWrite, заключается в формировании "обёртки" для системных объектов и библиотеки базовых компонентов, то и предалагаемые в репозитории примеры не отражают ограничения по созданию программ. Однако они могут быть полезны как варианты организации различных механизмов и функций. Вдобавок, многие классы могут быть взяты и использованы в других проектах, что, соотвтетсвенно, раскрывается в коде приведённых приложений.

### Arkanoid

Приложение представляет собой простой вариант известной одноименной игры. Цель состоит в том, чтобы набрать как можно больше очков за уничтожение блоков шариком. Количество получаемых очков увеличивается с количеством разрушенных блоков подряд (без столкновения шарика с платформой). При этом после каждого разрушения блока появляется ракета, летящая в сторону платформы. Эти ракеты могут быть уничтожены шариком, что приведет к взрыву, отбрасывающим шарик. При чем возможна цепная реакция: взрыв ракеты задевает другую ракету, что уничтожает другую, и так по цепочке. Игра завершается либо когда заканчиваются жизни, либо когда уничтожены все блоки. Каждый пропущенный до нижней границы шарик, то есть шарик, который ударяется о нижнюю стенку поля, снимает 1 жизнь. Также 1 жизнь снимается при попадании ракеты по платформе. Управление платформой производится с помощью клавиш-стрелок "влево" и "вправо", при чём скорость и длина платформы фиксированы. Скорость шарика увеличивается только при попадании по ракете и сбрасывается после потери жизни игроком.

![](/img/)

С программной точки зрения, здесь продемонстрирована работа со спрайтами (ракета, пиктограмма жизней), графическими примитивами (блоки, шарик, платформа), простыми 2D преобразованиями (отскок шарика, равноускоренное движение, проверка коллизий), текстом (вывод количества очков, надписей).

### StarField

Приложение отрисовывает простое чёрное поле с разноцветными пульсирующими и вращающимися звездами разных размеров и форм. По нему можно двигаться с помощью камеры: стрелочки осуществляют движение, клавиша Q - поворот против часовой стрелки, E - поворот по часовой стрелке, Z - приближение, X - отдаление.

![](/img/)

Этот проект примечателен тем, что демонстрирует работу аффинных преобразований в матричной форме.
